# 프로젝트 예산 분석

# *노력(Effort) 분석*

MM을 측정하기 위하여  개발과정에서 사용하는 4가지의 비용 예측 모델들을 비교하여 현 프로젝트에서 사용하기 적절한 모델을 판단하였다.

**전문가 분석 , PERT, COCOMO, 기능 점수 이 4가지의 모델을 평가했다.**

- **전문가 분석**이 가장 이상적이나 현재 조건으로는  전문가를 섭외할 수 있는 상황이 아니기 때문에 사용이 불가능하다.
- **PERT 모델**은 현재 개발자들이 낙관적, 보통, 비관적 예측치를 설정할 수 있는 능력이 부족하다고 판단되어 사용이 불가능하다.
- **COCOMO 모델**은 소스 코드 라인의 수를 예측할 역량이 안되기 때문에 사용이 불가능하다.
- **기능 점수 모델**은 프로젝트의 주된 기능을 설정하였으므로 사용이 가능하다.

따라서 비용 예측치를 설정하기 위해 **기능 점수 모델**을 사용하기로 결정하였다.

아래는 프로젝트에서 구현할 기능을 **코드, 팀 스페이스, 기타** 이 3가지로 나누고 각 기능들을 5가지의 기능분야(외부 입력, 외부 출력, 외부 조회, 내부 논리 파일, 외부 인터페이스)로 나눠서 평가한 결과이다.

---

## 기능

**코드와 관련된 기능 → 14개**

1. UML작성 툴
2. 코드 리뷰 툴
3. 코드 스크립트 환경
4. 컴파일 및 디버깅
5. 라이브 코딩 환경
6. UML 다이어그램 - 코드와의 linking
7. 코드 룰 설정
8. AI를 활용하여 UML 생성
9. 라이브 코드 저장
10. 브렌치 생성 및 변경 기능
11. 커밋 기능
12. 푸쉬 기능
13. 코드 리뷰 콜
14. 가상 터미널 환경 제공

**워크 스페이스와 관련된 기능 → 5개**

1. 데이터베이스 저장
2. 팀스페이스 기본 툴 제공
3. 라이브 팀스페이스 환경 제공
4. 멤버 초대 기능
5. 채팅 기능

**기타 기능 → 1개**

1. 로그인 & 로그아웃

---

## 기능 분야

### 외부 입력 → 16개

1. 로그인 정보를 입력하는 기능
2. UML을 작성하는 기능
3. 코드 리뷰를 작성하는 기능
4. 코드를 입력하는 기능
5. 라이브 코드 스크립트 환경 기능
6. 브렌치의 이름과 정보를 설정하는 기능
7. 브렌치를 변경하는 기능
8. 코드 룰을 설정하는 기능
9. 팀 스페이스 툴을 설정하는 기능
10. AI를 활용하여 코드를 분석해 UML을 만들어주는 기능
11. 코드를 컴파일하는 기능
12. 커밋을 실행하고 커밋 메세지를 작성하는 기능
13. 커밋된 코드를 푸쉬하는 기능
14. 라이브 코드 스크립트 환경에서 코드 리뷰어를 콜하는 기능
15. 채팅을 입력하는 기능
16. 가상 터미널에서 사용자 입력을 받는 기능

### 외부 출력 → 15개

1. 유저 정보를 출력하는 기능
2. 작성한 UML을 출력하는 기능
3. 작성한 코드 리뷰를 출력하는 기능
4. 작성한 코드를 출력하는 기능
5. 라이브로 작성하여 수정되는 코드를 확인하는 기능
6. 설정된 브렌치의 정보를 출력하는 기능
7. 설정한 코드 룰을 출력하는 기능
8. UML과 링크된 코드의 관계를 출력하는 기능
9. 설정한 팀 스페이스 툴을 출력하는 기능
10. AI로 작성된 UML의 결과를 출력하는 기능
11. 컴파일의 결과를 알려주는 기능
12. 커밋 로그를 알려주는 기능
13. 푸쉬결과를 알려주는 기능
14. 채팅정보를 출력하는 기능
15. 가상 터미널 내용을 출력하는 기능

### 외부 조회 → 10개

1. 유저 정보 데이터 베이스
2. 멤버 정보 데이터 베이스
3. 팀 데이터베이스
4. 코드 파일
5. 라이브 코드 저장 파일
6. 컴파일러
7. 코드 컴파일 결과를 저장하는 파일
8. 커밋 로그를 저장하는 파일
9. 푸쉬 기록을 저장하는 파일
10. 프로젝트 저장소 파일 데이터베이스

### 내부 논리 파일(데이터 그룹 및 파일) → 15개

1. 유저 데이터 그룹
2. 멤버 데이터 그룹
3. Repository 데이터 그룹
4. 팀 스페이스 환경 데이터 그룹
5. 작성한 코드를 저장하는 파일
6. 라이브로 작성된 코드를 시간별로 저장하는 파일
7. 팀 데이터베이스 그룹(문서, 표, 페이지)
8. 작성한 코드 리뷰 로그를 저장하는 파일
9. 작성된 UML을 저장하는 파일
10. 설정한 코드 룰을 저장하는 파일
11. 이식된 컴파일러 정보 그룹
12. 컴파일된 코드의 결과를 저장하는 파일
13. 커밋 로그를 저장하는 파일
14. 푸쉬 로그를 저장하는 파일
15. 프로젝트 저장소 파일 데이터베이스

### 외부 인터페이스 → 4개

1. 팀 스페이스의 설정된 툴과 요소들을 보여주는 인터페이스
2. 코드 스크립트 환경을 지원하는 인터페이스
3. UML 페이지를 지원하는 인터페이스
4. 로그인 화면을 지원하는 인터페이스

---

위의 기능 분야 분석 내용을 바탕으로 FP분석을 진행하였다. FP 판별표와 복잡도 선정 방식은 **국내 기능 점수 산정 가이드**에 따라서 평가하였고, 복잡도는 현재 프로젝트 인원이 특정 기능을 단순, 보통, 복잡 이 3가지에 따라 정확히 판단을 할 수 없다고 생각하여 **간이 계산값**을 사용하였다.

### GFP

|  | 기능분야 | 개수 |  | 복잡도 |  | 간이 계산값 |
| --- | --- | --- | --- | --- | --- | --- |
|  |  |  | 단순 | 보통 | 복잡 |  |
| 1 | 외부 입력 | 16 | 3 | 4 | 6 | 4 |
| 2 | 외부 출력 | 16 | 4 | 5 | 7 | 5.2 |
| 3 | 외부 조회 | 10 | 3 | 4 | 6 | 3.9 |
| 4 | 내부 논리 파일 | 15 | 7 | 10 | 15 | 7.5 |
| 5 | 외부 인터페이스 | 4 | 5 | 7 | 10 | 5.4 |

위의 표를 바탕으로 GFP를 계산하였다.

외부 입력 : $16 × 4 = 64$

외부 출력 : $16 × 5.2 = 83.2$

외부 조회 : $10 × 3.9 = 39$

내부 논리 파일 : $15 × 7.5 = 112.5$

외부 인터페이스 : $4 × 5.4 = 21.6$

$GFP = 64 + 83.2 + 39 + 112.5 + 21.6 = 320.3$

따라서 **GFP는 320.3**이 나왔다.

---

### PCA

**PCA 기준 표**

---

①시스템이 신뢰도 높은 백업과 복구를 요구하는가? → 5

②데이터 통신이 필요한가? → 5

③분산 처리 기능이 있는가? → 5

④성능이 중요한가? → 4

⑤시스템 과부하 운용 환경에서 실행되는가? → 3

⑥온라인 데이터 입력이 필요한가? → 5

⑦온라인 입력이 다중 화면 위에 구축되기 위하여 입력 트랜잭션이 필요한가? → 5

⑧마스터 파일이 온라인으로 갱신되어야 하는가? → 5

⑨입력, 출력, 파일, 질의가 복잡한가? → 3

⑩내부 처리가 복잡한가? → 3  

⑪재사용 되도록 설계되어야 하나? → 3

⑫변환과 설치가 설계에 포함되어야 하나? → 2

⑬다중 사이트에 설치되기 위하여 설계되었나? → 3

⑭변경과 사용이 쉽도록 설계되었나? → 3

---

 위에서 제시한 프로젝트 기능을 바탕으로 PCA항목점수를 평가하였다. 평가 점수는 표의 각 항목 옆에 제시하였다.

**5 점 → 6개**

**4 점 → 1개**

**3 점 → 6개**

**2 점 → 1개**

**1 점 → 0개**

**0 점 → 0개**

평가된 항목점수에 따라 PCA를 계산하였다.

$PCA = 0.65 + 0.01 ×(5×6+4×1+3×6+2×1) =1.19$

따라서 **PCA는 1.19**로 설정하였다.

설정한 GPF와 PCA의 값을 바탕으로 FP를 계산하였다.

$FP=320.3×1.19=381.157$

소수점은 첫번째 자리수까지 표시하여 **FP는 381.1**로 설정하였다.

**국내 기능 점수 당 평균 생산성은** 개발자의 역량을 고려하여 **예외값 하한**으로 잡았다. 따라서 **생산성은 21.8**로 설정했다.

아래는 위에서 설정한 FP와 생산성으로  M/M을 구하는 과정과 결과이다.

$MM = FP/생산성 = 381.1/21.8 = 17.481$

따라서 노력치(E)는  17.4 MM이다.

---

# 자원(Resource) 분석

개발 인력은 백엔드 개발자 2명, 프론트 엔드 개발자 2명, UI/UX 디자이너 1명, 서버 관리자 1명, 프로젝트 관리 및 QA(Quality Assurance) 1명 총 7명으로 각 파트별로  투입 비율을 판단하여 자원(R)을 설정하였다.

백엔드 개발자 : 50% → 1명

프론트 엔드 개발자 : 30% → 0.6명

UI/UX 디자이너 : 20% → 0.2명

서버 관리자  : 10% → 0.1명

프로젝트 관리 및 QA  : 10% → 0.1명

$1+0.6+0.2+0.1+0.1=2.0$

위의 결과에 따라 **자원은 2.0명**으로 설정하였다.

---

# 기간(Duration) 분석

노력(Effort)과 자원(Recourse)를 나눠서 기간(Duration)을 계산하였다.

노력 : 17.4 MM

자원 : 2.0 명

$D=E/M=17.4/2.0=8.7$

위의 결과에 따라 기간은 8.7개월로 설정하였다.

---

# 비용 예측 결과

노력(Effort) : 17.4 MM

자원(Recourse) : 2.0 명

기간(Duration) : 8.7개월

위에서 예측한 노력, 자원, 기간을 토대로 인력 비용과 기타 비용을 산정하였다.

인력비용은 기본 월 300만원을 할당하고 인력 비율을 100만원에 나눠서 추가로 할당하였다.

**인력 비용 산정**:

- 백엔드 개발자 2인 : $((300만원 +(100만원×0.5))×2=700만원$
- 프론트 엔드 개발자 2인 : $(300만원 +(100만원×0.3))×2=660만원$
- UI/UX 디자이너 1인 : $300만원 +(100만원×0.2)=320만원$
- 서버 관리자 1인 : $300만원 +(100만원×0.1)=310만원$
- 프로젝트 관리 및 QA 1인 : :$300만원 +(100만원×0.1)=310만원$

1개월당 인력비용 :  $700만원+660만원+320만원+310만원+310만원=2300만원$

프로젝트 기간 인력비용 : $2300만원 × 8.7=20,010만원$

또한 추가 작업이 생길 사항을 고려해 2000만원을 추가하여 총 **22,010만원**으로 프로젝트 인력 비용을 산정했다.

**기타 비용 산정**

- 테스트 비용 : $300만원(테스트  인원) + 250만원(테스트 도구) = 550만원$
- 서버 유지 비용 : $80만원(월)×8.7=696만원$
- 데이터베이스 관리 비용 : $50만원(월)+8.7=435만원$

총 기타 비용 : $550만원 + 696만원+435만원 =1681만원$

**총 예산 계산**:

- 총 인력 비용: 22,010만원
- 기타 비용: 1681만원
- 총 예산 : $22,010만원+1681만원=23,691만원$

따라서 총 예산 예측치는 **23,691만원**으로 산정했다.
