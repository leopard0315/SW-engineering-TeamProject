# 프로젝트 헌장

- 작성자 : 김민혁, 이재민, 최혁

<br>

## 목차

### 1. [프로젝트 명](#프로젝트-명)

### 2. [프로젝트 목적 및 당위성](#프로젝트-목적-및-당위성)

### 3. [프로젝트 목표](#프로젝트-목표)

### 4. [프로젝트 범위](#프로젝트-범위)

### 5. [성공 기준](#성공-기준)

### 6. [프로젝트 관리](#프로젝트-관리)

### 7. [일정 및 마일스톤 예측](#일정-및-마일스톤-예측)

### 8. [필요 자원](#필요-자원)

### 9. [예산 예측치](#예산-예측치)

### 10. [예측 근거 분석 내용](#예측-근거-분석-내용)

<br>

<br>

<br>

## *프로젝트 명*

- 코드퍼레이트(Codeperate) 워크스페이스 개발 프로젝트

<br>
<br>

## *프로젝트 목적 및 당위성*

### 프로젝트 목적

- 프로젝트 목적은 개발자를 위한 코드리뷰 기능을 포함한 다양한 기능이 탑재가 되어 있는 워크스페이스 프로그램을 제공하는 것이다. 이 프로그램은 작성한 UML, 코드 리뷰, Branch 상의 코드 이 3가지가 유기적으로 연결되어있는 **개발 구조 linking 기능**, Branch의 사용자가 코드를 수정할 때 실시간으로 팀 스페이스 내의 멤버들이 수정 사항을 확인하고 같이 수정 가능한 **코드 라이브 수정 기능**, 마지막으로 코드의 일관성을 유지할 수 있는 **코드 룰 설정 기능** 이 3가지를 제공한다. 위 3가지의 기능을 바탕으로 **개발자가 팀 프로젝트를 진행할 때 오류 발생 확률을 감소하고 원활한 팀 프로젝트 활동을 지원하도록 하는 것**이 해당 프로젝트의 주된 목적이다.

### 설문조사

- 프로그래머스에서 진행한 **2023 개발자 설문조사**에 따르면 **팀 협업을 진행할 때 가장 선호하는 개발 문화**는 **코드 리뷰**가 42.3%로 가장 많은 비율을 차지했다.
- 본 프로그램은 개발자가 팀 협업 프로젝트를 진행할 때 필요한 ***UML 작성, 코드 리뷰, 라이브 코드 수정 , 코드 룰 설정*** 등 여러가지 기능을 지원한다. 또한 시중에 존재하는 팀 워크스페이스 툴이 지니고 있는 보편적인 기능들을 제공하여 여러 팀 워크스페이스를 사용하는 것이 아닌 하나의 프로그램 내에서 모든 팀 프로젝트 활동을 지원할 수 있는 기능을 제공한다.

<br>
<br>

## *프로젝트 목표,  범위 및 성공 기준*

### 프로젝트 목표

1. **보편적인 개발자 팀 협업 툴 정착**

    개발자를 위한 툴로 제작하여 개발 관련해서 팁 협업을 진행하는 회사에서 보편적으로 쓰일 수 있는 툴로 정착 시킨다.

2. **예비 개발자 및 주니어 개발자를 위한 워크스페이스**

    아직 팁 협업에 익숙하지 않은 예비 개발자, 학생, 주니어 개발자들이 해당 프로그램으로 팁 협업을 진행하는 것을 도와준다. 또한 학교나 예비 개발자, 주니어 개발자가 다수 존재하는 그룹에다가 해당 프로그램을 지원하여 인지도를 높이고 나아가 기업들이 해당 프로그램을 사용하도록 할 수 있게 하는 것이 목표이다.

3. **소규모 프로젝트에서 효율적으로 사용 가능한 워크스페이스**

    라이브 코드 스크립트 환경을 제공해서 개발자가 2 ~ 5인으로 이루어진 프로젝트에서 효율적으로 사용이 가능하다. 따라서 대규모 프로젝트 뿐만 아니라 소규모 프로젝트에 효과적인 기능을 제공해서 개발자들의 효율적인 팀 협업을 지원하는 것이 목표이다.
<br>

<br>

## *프로젝트 범위*

- **프로젝트가 해결하는 문제**
  - 브렌치 상의 코드와 코드 리뷰의 연결 및 이동
  - UML과 브렌치 상의 코드의 연결 및 이동
  - 코드 룰을 설정
  - 라이브 코드 환경
  - 코드 리뷰어를 호출
  - 실시간 코드 리뷰
  - 각 Branch의 흐름을 제시
  - 코드 리뷰 툴
  - 팀 스페이스 기본 툴 제공
  - 데이터베이스 저장
  - 라이브 팀스페이스 환경 제공
  - 채팅
  - 라이브 코드 저장

- **프로젝트가 해결하지 않는 문제 (별도의 시스템개발or 외주 맡김)**
  - 팀 워크스페이스 로그인 & 로그아웃
  - UML작성 툴
  - 코드 스크립트 환경 & 컴파일러
  - AI를 활용하여 UML 생성
  - Branch 생성 및 변경
  - 커밋 기능
  - 푸쉬 기능
  - 가상 터미널 환경
  - 멤버 초대

<br>
<br>

## *성공 기준*

- 개발 관련 회사들이 사용하는 팁 협업 워크스페이스 중에서 시장 점유율 초기 5% 달성.
- 학교, 개발자 그룹에서 사용하는 툴로 초기 30% 시장 점유율 확보.

<br>
<br>

## *프로젝트 관리*

- 팀원들과의 커뮤니케이션은 Slack으로 진행하며 프로젝트의 진행과정 및 일정 그리고 모든 문서는 팀 공유 Notion에 저장한다.

### *팀 내 및 경영진에 대한 의사소통 계획*

- 팀원들은 월요일마다 주간 회의를 진행하고 필요시에 회의 일정을 추가한다.
- 팀원들과의 소통이 필요할 시에 Slack을 통해 의사소통을 진행한다.
- 경영진과 Notion의 팀 워크스페이스 기록을 공유하며 Slack을 통해 해당 프로젝트의 진행 사항을 보고한다.
- 경영진과는 이메일과 Slack으로 의견을 조율하며 변경되는 사항이나 알림 사항은 Slack을 통해 알린다.

<br>
<br>

## *일정 및 마일스톤 예측*

- 마일스톤 3~4개이상
- 소요기간 12개월에서 15개월 맞추기(구현 9개월 + 테스트 3~6개월)

<br>
<br>

## *필요 자원*

- 필요 인력 : 백엔드 개발자 2명, 프론트 엔드 개발자 2명, UI/UX 디자이너 1명, 서버 관리자 1명, 프로젝트 관리 및 QA(Quality Assurance) 1명 ⇒ 총 7명
- 필요 장비 :  데스크탑 3대, 랩탑 6대
- 기타 필요 자원 : 클라우드 서버, 데이터베이스, 테스트 모듈
<br>

<br>

## *예산 예측치*

- **기간**
  - 설계 기간 : 3개월
  - 개발 기간 : 9개월
  - 테스트 기간 : 7개월
  - 전체 기간 : 19개월
- **총 예산**:
  - 총 인력 비용 : 22,010만원
  - 기타 비용(테스트 비용, 데이터베이스 관리 비용, 서버 유지 비용) : 1681만원
  - 총 예산 : $22,010만원+1681만원=23,691만원$
<br>

<br>

## *예측 근거 분석 내용*

프로젝트의 일정과 예산을 도출하기위해 분석한 내용을 아래에 작성하였다.

<br>

### 프로젝트 일정 분석
프로젝트의 일정을 분석하기 위해 작업 분할도(WBS)와 를 작성하였다
### WBS
![WBS 최종수정본](https://github.com/choi-hyk/SW-engineering-TeamProject/assets/127075917/86b79514-5eb1-4ea6-8b2d-7653e7922808)

### 작업 의존 관계 파악
세부 작업간 의존 관계와 각 작업의 소요기간을 표로 정리하였다.



### CPM 네트워크
![CPM 네트워크 계산](https://github.com/choi-hyk/SW-engineering-TeamProject/assets/127075917/dffe2357-cb9a-46d8-8b10-7266b034dddd)

### 임계경로
CPM 네트워크를 통해 임계경로를 계산하였다.

<br>
<br>

### 프로젝트 예산 분석

<br>

프로젝트의 예산 분석을 하기 위해 노력, 자원, 기간을 기능과 예산 측면에서 분석을 했다.

<br>

## *노력(Effort) 분석*

MM을 측정하기 위하여  개발과정에서 사용하는 4가지의 비용 예측 모델들을 비교하여 현 프로젝트에서 사용하기 적절한 모델을 판단하였다.

**전문가 분석 , PERT, COCOMO, 기능 점수 이 4가지의 모델을 평가했다.**

- **전문가 분석**이 가장 이상적이나 현재 조건으로는  전문가를 섭외할 수 있는 상황이 아니기 때문에 사용이 불가능하다.
- **PERT 모델**은 현재 개발자들이 낙관적, 보통, 비관적 예측치를 설정할 수 있는 능력이 부족하다고 판단되어 사용이 불가능하다.
- **COCOMO 모델**은 소스 코드 라인의 수를 예측할 역량이 안되기 때문에 사용이 불가능하다.
- **기능 점수 모델**은 프로젝트의 주된 기능을 설정하였으므로 사용이 가능하다.

따라서 비용 예측치를 설정하기 위해 **기능 점수 모델**을 사용하기로 결정하였다.

아래는 프로젝트에서 구현할 기능을 **코드, 팀 스페이스, 기타** 이 3가지로 나누고 각 기능들을 5가지의 기능분야(외부 입력, 외부 출력, 외부 조회, 내부 논리 파일, 외부 인터페이스)로 나눠서 평가한 결과이다.

<br>
<br>

#### 기능

**코드와 관련된 기능 → 14개**

1. UML작성 툴
2. 코드 리뷰 툴
3. 코드 스크립트 환경
4. 컴파일 및 디버깅
5. 라이브 코딩 환경
6. UML 다이어그램 - 코드와의 linking
7. 코드 룰 설정
8. AI를 활용하여 UML 생성
9. 라이브 코드 저장
10. 브렌치 생성 및 변경 기능
11. 커밋 기능
12. 푸쉬 기능
13. 코드 리뷰 콜
14. 가상 터미널 환경 제공

**워크 스페이스와 관련된 기능 → 5개**

1. 데이터베이스 저장
2. 팀스페이스 기본 툴 제공
3. 라이브 팀스페이스 환경 제공
4. 멤버 초대 기능
5. 채팅 기능

**기타 기능 → 1개**

1. 로그인 & 로그아웃
<br>

<br>

#### 기능 분야

### 외부 입력 → 16개

1. 로그인 정보를 입력하는 기능
2. UML을 작성하는 기능
3. 코드 리뷰를 작성하는 기능
4. 코드를 입력하는 기능
5. 라이브 코드 스크립트 환경 기능
6. 브렌치의 이름과 정보를 설정하는 기능
7. 브렌치를 변경하는 기능
8. 코드 룰을 설정하는 기능
9. 팀 스페이스 툴을 설정하는 기능
10. AI를 활용하여 코드를 분석해 UML을 만들어주는 기능
11. 코드를 컴파일하는 기능
12. 커밋을 실행하고 커밋 메세지를 작성하는 기능
13. 커밋된 코드를 푸쉬하는 기능
14. 라이브 코드 스크립트 환경에서 코드 리뷰어를 콜하는 기능
15. 채팅을 입력하는 기능
16. 가상 터미널에서 사용자 입력을 받는 기능

### 외부 출력 → 15개

1. 유저 정보를 출력하는 기능
2. 작성한 UML을 출력하는 기능
3. 작성한 코드 리뷰를 출력하는 기능
4. 작성한 코드를 출력하는 기능
5. 라이브로 작성하여 수정되는 코드를 확인하는 기능
6. 설정된 브렌치의 정보를 출력하는 기능
7. 설정한 코드 룰을 출력하는 기능
8. UML과 링크된 코드의 관계를 출력하는 기능
9. 설정한 팀 스페이스 툴을 출력하는 기능
10. AI로 작성된 UML의 결과를 출력하는 기능
11. 컴파일의 결과를 알려주는 기능
12. 커밋 로그를 알려주는 기능
13. 푸쉬결과를 알려주는 기능
14. 채팅정보를 출력하는 기능
15. 가상 터미널 내용을 출력하는 기능

### 외부 조회 → 10개

1. 유저 정보 데이터 베이스
2. 멤버 정보 데이터 베이스
3. 팀 데이터베이스
4. 코드 파일
5. 라이브 코드 저장 파일
6. 컴파일러
7. 코드 컴파일 결과를 저장하는 파일
8. 커밋 로그를 저장하는 파일
9. 푸쉬 기록을 저장하는 파일
10. 프로젝트 저장소 파일 데이터베이스

### 내부 논리 파일(데이터 그룹 및 파일) → 15개

1. 유저 데이터 그룹
2. 멤버 데이터 그룹
3. Repository 데이터 그룹
4. 팀 스페이스 환경 데이터 그룹
5. 작성한 코드를 저장하는 파일
6. 라이브로 작성된 코드를 시간별로 저장하는 파일
7. 팀 데이터베이스 그룹(문서, 표, 페이지)
8. 작성한 코드 리뷰 로그를 저장하는 파일
9. 작성된 UML을 저장하는 파일
10. 설정한 코드 룰을 저장하는 파일
11. 이식된 컴파일러 정보 그룹
12. 컴파일된 코드의 결과를 저장하는 파일
13. 커밋 로그를 저장하는 파일
14. 푸쉬 로그를 저장하는 파일
15. 프로젝트 저장소 파일 데이터베이스

### 외부 인터페이스 → 4개

1. 팀 스페이스의 설정된 툴과 요소들을 보여주는 인터페이스
2. 코드 스크립트 환경을 지원하는 인터페이스
3. UML 페이지를 지원하는 인터페이스
4. 로그인 화면을 지원하는 인터페이스

위의 기능 분야 분석 내용을 바탕으로 FP분석을 진행하였다. FP 판별표와 복잡도 선정 방식은 **국내 기능 점수 산정 가이드**에 따라서 평가하였고, 복잡도는 현재 프로젝트 인원이 특정 기능을 단순, 보통, 복잡 이 3가지에 따라 정확히 판단을 할 수 없다고 생각하여 **간이 계산값**을 사용하였다.
<br>
<br>

### GFP

|  | 기능분야 | 개수 |  | 복잡도 |  | 간이 계산값 |
| --- | --- | --- | --- | --- | --- | --- |
|  |  |  | 단순 | 보통 | 복잡 |  |
| 1 | 외부 입력 | 16 | 3 | 4 | 6 | 4 |
| 2 | 외부 출력 | 16 | 4 | 5 | 7 | 5.2 |
| 3 | 외부 조회 | 10 | 3 | 4 | 6 | 3.9 |
| 4 | 내부 논리 파일 | 15 | 7 | 10 | 15 | 7.5 |
| 5 | 외부 인터페이스 | 4 | 5 | 7 | 10 | 5.4 |

위의 표를 바탕으로 GFP를 계산하였다.

외부 입력 : $16 × 4 = 64$

외부 출력 : $16 × 5.2 = 83.2$

외부 조회 : $10 × 3.9 = 39$

내부 논리 파일 : $15 × 7.5 = 112.5$

외부 인터페이스 : $4 × 5.4 = 21.6$

$GFP = 64 + 83.2 + 39 + 112.5 + 21.6 = 320.3$

따라서 **GFP는 320.3**이 나왔다.
<br>
<br>

### PCA

**PCA 기준 표**

①시스템이 신뢰도 높은 백업과 복구를 요구하는가? → 5

②데이터 통신이 필요한가? → 5

③분산 처리 기능이 있는가? → 5

④성능이 중요한가? → 4

⑤시스템 과부하 운용 환경에서 실행되는가? → 3

⑥온라인 데이터 입력이 필요한가? → 5

⑦온라인 입력이 다중 화면 위에 구축되기 위하여 입력 트랜잭션이 필요한가? → 5

⑧마스터 파일이 온라인으로 갱신되어야 하는가? → 5

⑨입력, 출력, 파일, 질의가 복잡한가? → 3

⑩내부 처리가 복잡한가? → 3  

⑪재사용 되도록 설계되어야 하나? → 3

⑫변환과 설치가 설계에 포함되어야 하나? → 2

⑬다중 사이트에 설치되기 위하여 설계되었나? → 3

⑭변경과 사용이 쉽도록 설계되었나? → 3

 위에서 제시한 프로젝트 기능을 바탕으로 PCA항목점수를 평가하였다. 평가 점수는 표의 각 항목 옆에 제시하였다.

**5 점 → 6개**

**4 점 → 1개**

**3 점 → 6개**

**2 점 → 1개**

**1 점 → 0개**

**0 점 → 0개**

평가된 항목점수에 따라 PCA를 계산하였다.

$PCA = 0.65 + 0.01 ×(5×6+4×1+3×6+2×1) =1.19$

따라서 **PCA는 1.19**로 설정하였다.

설정한 GPF와 PCA의 값을 바탕으로 FP를 계산하였다.

$FP=320.3×1.19=381.157$

소수점은 첫번째 자리수까지 표시하여 **FP는 381.1**로 설정하였다.

**국내 기능 점수 당 평균 생산성은** 개발자의 역량을 고려하여 **예외값 하한**으로 잡았다. 따라서 **생산성은 21.8**로 설정했다.

아래는 위에서 설정한 FP와 생산성으로  M/M을 구하는 과정과 결과이다.

$MM = FP/생산성 = 381.1/21.8 = 17.481$

따라서 노력치(E)는  17.4 MM이다.
<br>
<br>

## 자원(Resource) 분석

개발 인력은 백엔드 개발자 2명, 프론트 엔드 개발자 2명, UI/UX 디자이너 1명, 서버 관리자 1명, 프로젝트 관리 및 QA(Quality Assurance) 1명 총 7명으로 각 파트별로  투입 비율을 판단하여 자원(R)을 설정하였다.

백엔드 개발자 : 50% → 1명

프론트 엔드 개발자 : 30% → 0.6명

UI/UX 디자이너 : 20% → 0.2명

서버 관리자  : 10% → 0.1명

프로젝트 관리 및 QA  : 10% → 0.1명

$1+0.6+0.2+0.1+0.1=2.0$

위의 결과에 따라 **자원은 2.0명**으로 설정하였다.
<br>
<br>

## 기간(Duration) 분석

노력(Effort)과 자원(Recourse)를 나눠서 기간(Duration)을 계산하였다.

노력 : 17.4 MM

자원 : 2.0 명

$D=E/M=17.4/2.0=8.7$

위의 결과에 따라 기간은 8.7개월로 설정하였다.
<br>
<br>

## 비용 예측 결과

노력(Effort) : 17.4 MM

자원(Recourse) : 2.0 명

기간(Duration) : 8.7개월

위에서 예측한 노력, 자원, 기간을 토대로 인력 비용과 기타 비용을 산정하였다.

인력비용은 기본 월 300만원을 할당하고 인력 비율을 100만원에 나눠서 추가로 할당하였다.

**인력 비용 산정**:

- 백엔드 개발자 2인 : $((300만원 +(100만원×0.5))×2=700만원$
- 프론트 엔드 개발자 2인 : $(300만원 +(100만원×0.3))×2=660만원$
- UI/UX 디자이너 1인 : $300만원 +(100만원×0.2)=320만원$
- 서버 관리자 1인 : $300만원 +(100만원×0.1)=310만원$
- 프로젝트 관리 및 QA 1인 : :$300만원 +(100만원×0.1)=310만원$

1개월당 인력비용 :  $700만원+660만원+320만원+310만원+310만원=2300만원$

프로젝트 기간 인력비용 : $2300만원 × 8.7=20,010만원$

또한 추가 작업이 생길 사항을 고려해 2000만원을 추가하여 총 **22,010만원**으로 프로젝트 인력 비용을 산정했다.

**기타 비용 산정**

- 테스트 비용 : $300만원(테스트  인원) + 250만원(테스트 도구) = 550만원$
- 서버 유지 비용 : $80만원(월)×8.7=696만원$
- 데이터베이스 관리 비용 : $50만원(월)+8.7=435만원$

총 기타 비용 : $550만원 + 696만원+435만원 =1681만원$

**총 예산 계산**:

- 총 인력 비용: 22,010만원
- 기타 비용: 1681만원
- 총 예산 : $22,010만원+1681만원=23,691만원$

따라서 총 예산 예측치는 **23,691만원**으로 산정했다.
